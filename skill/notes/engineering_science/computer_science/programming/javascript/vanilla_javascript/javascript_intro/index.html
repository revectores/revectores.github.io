<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title> JavaScript Introduction
 </title>
  
  <link rel="stylesheet" type="text/css" href="http://revectores.com//static/css/newsprint.css"> 
  <link rel="stylesheet" type="text/css" href="http://revectores.com//static/css/blog.css"> 
  <link rel="stylesheet" type="text/css" href="http://revectores.com//static/css/code.css"> 
  
</head>
<body>

<p><a href="../"><< vanilla_javascript</a></p>

<h1 id="javascript-introduction">JavaScript Introduction</h1>
<h3 id="basic-misc">1. Basic MISC</h3>
<h5 id="introduction"># Introduction</h5>
<p>JavaScript语言本身不仅仅可以在浏览器中运行, 而是可以在任何搭建了JS解释器的平台上被解释(Node.js, Unity3D, Cocos). 本文档仅仅对JS语言本身的特性进行介绍, 不涉及任何依赖于平台的内容.</p>
<h5 id="comment"># Comment</h5>
<p>单行注释为双斜杠//, 多行注释前后由/* */括起.</p>
<h5 id="delimeter"># Delimeter</h5>
<p>JavaScript语句由分号分割, 但也允许省略, JS会在缺少分号且无法正确解析代码时自动添加分号. 也就是说如果缺少分号的多行忽略换行符后可以正确解析, 则JS不会对其进行分割, 例如:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">var</span> a</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>a</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="op">=</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="dv">3</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(a)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="co">//javascript will consider it as:</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="kw">var</span> a<span class="op">;</span> a<span class="op">=</span><span class="dv">3</span><span class="op">;</span> <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(a)<span class="op">;</span></span></code></pre></div>
<p>分号可以用于在一行中写多个语句. 早期这个操作常常用于缩小JS大小从而降低文件传输时间, 用于生产环境的JS常常都被压缩在一行内. 实际上这个操作只能省几个<code>\n</code>, 目前JS文件大小已经不会再成为性能瓶颈, 这个需求已经不再有意义, 目前如多在一行中写多个语句更多是为了可读性的考虑.</p>
<p>在字符串中可以通过<code>\</code>来换行.</p>
<h3 id="variable">2. Variable</h3>
<h5 id="declaration"># Declaration</h5>
<p>传统的JavaScript语法使用<code>var [varname]</code>声明一个变量. 一个<code>var</code>可以同时声明多个变量, 它们之间用逗号连接. JavaScript作为动态语言, 在进行变量声明时并不需要指定类型. JS的变量名区分大小写.</p>
<p>允许在声明同时对变量进行赋值. 不赋值时变量值为<code>undefined</code>, 这实际上是一个特殊的数据类型. 有时, 为了让变量实际上拥有我们之后希望赋予的类型, 我们会通过<code>var [var_name] = new [type_name]</code>的方式为变量赋于一个目标类型的默认值. 例如Number类的实例则为0, string类型则为空字符串等等.</p>
<h5 id="data-type"># Data Type</h5>
<p>我们在<a href="http://revectores.com/skill/notes/engineering_science/computer_science/programming_language/javascript/vanilla_javascript/javascript_data_type/javascript_data_type.md">javascript_data_type</a>中详细介绍JavaScript变量的数据类型.</p>
<h5 id="scope"># Scope</h5>
<p>在函数内用<code>var</code>语句声明的变量是局部变量, 在函数外用<code>var</code>语句声明的则是全局变量. 如果在函数内对未声明的变量进行赋值操作, 该变量将被自动声明为全局变量.</p>
<h3 id="basic-opeartion">2. Basic Opeartion</h3>
<h5 id="calculation"># Calculation</h5>
<p>加法运算允许在数字之间、字符串之间(连接操作), 以及在数字和字符串之间进行, 在最后这种混杂的情况下, 数字将被隐式转换为字符串再进行字符串连接操作. 然后对于其他运算(减法、乘法和除法)而言, 数字和字符串之间的运算都被转化为数字运算.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> <span class="st">&quot;1&quot;</span> <span class="op">+</span> <span class="st">&quot;1&quot;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="st">&quot;11&quot;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> <span class="st">&quot;1&quot;</span> <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="st">&quot;11&quot;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="co">// but:</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> <span class="st">&quot;1&quot;</span> <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a><span class="dv">0</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> <span class="st">&quot;1&quot;</span> <span class="op">*</span> <span class="dv">3</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a><span class="dv">3</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> <span class="st">&quot;6&quot;</span> <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a><span class="dv">3</span></span></code></pre></div>
<p>我们也可以利用隐式转换的特点来进行类型转换:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="co">// convert a numeric string to number by multipling 1:</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> <span class="st">&quot;123&quot;</span> <span class="op">*</span> <span class="dv">1</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="dv">123</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a><span class="co">// notice that if the string is not a numeric, you&#39;ll get NaN</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> <span class="st">&quot;123a&quot;</span> <span class="op">*</span> <span class="dv">1</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a><span class="kw">NaN</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a><span class="co">// And we can also change a number into a string:</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> <span class="dv">123</span> <span class="op">+</span> <span class="st">&quot;&quot;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a><span class="st">&quot;123&quot;</span></span></code></pre></div>
<p>JavaScript和大多数正常的语言一样, 除法运算不取整. 取余运算用百分号%表示. JS支持自增和自减操作, 支持算术操作符放在等号左边.</p>
<h5 id="equality"># Equality</h5>
<p>JS提供了两种相等层次, 一般的相等<code>==</code>要求值相等, 而全等<code>===</code>则必须值和类型都相等. 在<code>==</code>比较中隐含了隐式转换的过程. 例如:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> <span class="kw">var</span> x <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> x <span class="op">===</span> <span class="st">&#39;5&#39;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="kw">false</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> x <span class="op">===</span> <span class="dv">5</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a><span class="kw">true</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> x <span class="op">==</span> <span class="st">&#39;5&#39;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a><span class="kw">true</span></span></code></pre></div>
<p>类似于不等号<code>!=</code>, 不全等号为<code>!==</code>.</p>
<p>NaN和不等于任何东西, 包括它自身.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> <span class="kw">NaN</span> <span class="op">==</span> <span class="kw">NaN</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="kw">false</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a><span class="co">// Use isNaN() function to check whether a variable is NaN:</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> x <span class="op">=</span> <span class="kw">NaN</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a><span class="op">&gt;&gt;&gt;</span> <span class="pp">isNaN</span>(x)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a><span class="kw">true</span></span></code></pre></div>
<p>上面提到, JS的弱类型特点会给算术运算的理解带来很多麻烦, 对于比较运算也是如此. JS的比较运算非常混乱, 以至于好事者将其做成了一个表格: http://thomas-yang.me/projects/oh-my-dear-js/</p>
<h3 id="function">3. Function</h3>
<div class="sourceCode" id="cb6"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">function</span> [func_name] ([args]){</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>    <span class="co">// ...</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>    <span class="cf">return</span> [value]</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>}</span></code></pre></div>
<h3 id="control-structure">4. Control Structure</h3>
<h5 id="condition-structure"># Condition Structure</h5>
<p>JS的条件结构很常规, 包含if和swith并遵循C的一般规范, if/else if后面跟的条件由括号括起, 代码块由大括号标识. swith语句分支需要由break执行退出功能, default语句指定没有匹配时的行为.</p>
<p>支持三元运算符: 条件?表达式1:表达式2</p>
<h5 id="cycle-structure"># Cycle Structure</h5>
<p>循环结构同样遵循C规范, 有趣的是其for语句允许类似Python迭代器的for(…in…)用法, 注意到在JS中后面有括号括起. 循环过程允许break和continue.</p>
<h3 id="error-handling">5. Error Handling</h3>
<p>try…catch(err)…语句用于捕获并处理错误信息, 机制和Python中的try…except…类似, 属性err.message用于获取错误的具体信息.</p>
<h3 id="object-oriented-techiques">6. Object Oriented Techiques</h3>
<p>在JS中一切都是对象. 任何一个变量(无论它是以哪种方式创建的)和函数都是对象. 我们知道对象的特点就是拥有属性和方法, 在以后的内容中我们会具体介绍JS内建对象(如字符串、数字等)的内建属性和方法. 这里只讨论面向对象的一般技术内容.</p>
<p>除了内建对象以外, JS允许我们通过<code>new Object()</code>直接创建自己的对象. 创建了对象以后我们就可以向它随意添加属性与方法并在未来访问. 我们也可以在对象创建之初就定义属性和方法</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>person <span class="op">=</span> {</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>    <span class="dt">age</span><span class="op">:</span> <span class="dv">20</span><span class="op">,</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>    <span class="dt">name</span><span class="op">:</span> <span class="st">&#39;robert&#39;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>}</span></code></pre></div>
<p>如果一系列对象都具有相同的属性, 那么逐一创建它们就会显得非常繁琐, 因此JS提供了对象构造器:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">function</span> <span class="fu">objectCreaterName</span>(property1<span class="op">,</span> property2<span class="op">,</span> <span class="op">...</span>) {</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">property1</span> <span class="op">=</span> property1<span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">property2</span> <span class="op">=</span> property2<span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>    <span class="kw">function</span> <span class="fu">method1</span>(arg1<span class="op">,</span>arg2<span class="op">,...</span>) {</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>        <span class="co">// ...</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>    }</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>}</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a><span class="co">// Then we can use this &quot;objectCreater&quot; to create new object.</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a><span class="kw">var</span> objectName <span class="op">=</span> <span class="kw">new</span> <span class="fu">ObjectCreaterName</span>(pro1<span class="op">,</span> pro2<span class="op">,</span> <span class="op">...</span>)</span></code></pre></div>
<p>这里所谓的对象构造器非常类似于类的功能, 而下面的语法就像是在创建一个类的实例一样(就正如我们在赋值语句中所做的那样). 但是JavaScript不把它称为类.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>实际上这里的operator overloading究竟应当代表何种意义完全是人为规定的.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>


</body>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</html>
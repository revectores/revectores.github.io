<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title> Mathematical Logic
 </title>
  
  <link rel="stylesheet" type="text/css" href="http://revectores.com//static/css/newsprint.css"> 
  <link rel="stylesheet" type="text/css" href="http://revectores.com//static/css/blog.css"> 
  <link rel="stylesheet" type="text/css" href="http://revectores.com//static/css/code.css"> 
  
</head>
<body>

<p><a href="../"><< mathematical_logic</a></p>

<h1 id="mathematical-logic">Mathematical Logic</h1>
<p><span class="math display">\[
\newcommand{\negp}{\neg p}
\newcommand{\negq}{\neg q}
\newcommand{\negr}{\neg r}
\newcommand{\r}{\rightarrow}
\newcommand{\rl}{\leftrightarrow}
\newcommand{\any}{\forall}
\]</span></p>
<h3 id="proposition-logic">1. Proposition Logic</h3>
<h5 id="proposition"># Proposition</h5>
<p>Proposition is a statement which got a determined truth value. <strong>Atomic Proposition</strong> is proposition which is indivisible, <strong>Compound Proposition</strong> is combined by atomic propositions.</p>
<h5 id="operations"># Operations</h5>
<p>There’re five basic operations affected on propositions, one unary operation and four binary operation, the binary operation are also called <strong>Connective</strong>. Operations includes <strong>negation</strong> <span class="math inline">\(\neg p\)</span>, <strong>conjunction</strong> <span class="math inline">\(p \land q\)</span>, <strong>disjunction</strong> <span class="math inline">\(p\lor q\)</span>, <strong>implication</strong> <span class="math inline">\(p\rightarrow q\)</span>, and <strong>equivalence</strong> <span class="math inline">\(p\leftrightarrow q\)</span>.</p>
<p>In the implication connective, <span class="math inline">\(p\)</span> is called antecedent, <span class="math inline">\(q\)</span> is called seccedent. The implication is false <strong>if and only if</strong> <span class="math inline">\(p=1,\ q=0\)</span>. In other words, the truth table of this</p>
<p>==TODO: Draw truth table for implication, and develop the method of auto-generating truth table.==</p>
<p>This implies an important feature about implication, which usually called <strong>implication identity</strong>: <span class="math display">\[
p\r q \quad=\quad \negp\lor q
\]</span> This is important in the transformation of logic expression, which converts the abstract implication into simple disjunction.</p>
<h5 id="proposition-formula"># Proposition Formula</h5>
<p>A variable that represents a proposition is called <strong>proposition variable</strong>, and the const proposition is called <strong>proposition const</strong>. We defined the proposition formula recursively like this:</p>
<ol type="1">
<li>Single proposition variable or proposition const is proposition formula.</li>
<li>If <span class="math inline">\(A,\ B\)</span> are proposition formula, <span class="math inline">\(\neg A, \ A\land B, \ A\lor B, \ A\r B, \ A \rl B\)</span> are all proposition formula.</li>
</ol>
<p>Only those symbol string can be generated from those two rules are proposition formula.</p>
<p>Notice that the proposition formula is just the <strong>form</strong> of proposition but not the actual proposition. For instance, the formula <span class="math inline">\(A: p\r q\)</span> is a proposition formula, only when we let <span class="math inline">\(p=\text{It&#39;s sunny}\)</span>, <span class="math inline">\(q=\text{we&#39;re going to hiking}\)</span>, or let <span class="math inline">\(p=\text{One works hard}\)</span>, <span class="math inline">\(q=\text{One gets grade 4.0}\)</span>, then the formula becomes a proposition after the assignment. This shows that multiple different propositions can be abstracted into the same proposition formula. This distinction is quite important because this <u>drived the grammar from specific semantic, which makes the inference a pure symbol conversion process.</u></p>
<p>For the convenience of further discription, the proposition variable and its negation are called <strong>literal</strong> uniformly, because of there’s no difference in the formula for weather a variable got a negation symbol right before it.</p>
<h5 id="functionally-complete-set"># Functionally Complete Set</h5>
<p>A set of connective is <strong>functionally complete</strong>, if any logic function can be expression only by its elements. If any connective in the set can’t be generated by others in the set, it’s called <strong>minimal functionally complete set</strong>.</p>
<p>For example, The set <span class="math inline">\(\{\neg, \land, \lor\}\)</span> is functionally complete (because any truth table can be expressed as PDNF) but not minimal, because conjuction and disjuction can expressed each other based on the De Morgan’s Law (with the help with negation): <span class="math display">\[
p\land q = \neg(\negp\lor\negq),
\quad\quad 
p\land q = \neg(\negp\land\negq)
\]</span> By deleting one of these two, the set <span class="math inline">\(\{\neg, \land\}\)</span> or <span class="math inline">\(\{\neg,\lor\}\)</span> is minial functionally complete. This can be proved by further methods.</p>
<p>We noticed that we can’t use only one connective to express all the logic function based on the most basic <span class="math inline">\(\{\neg, \land, \lor\}\)</span>, but it’s possible to use <span class="math inline">\(\r\)</span>, this is demonstrated as followed:</p>
<blockquote>
<p>Ex. <span class="math inline">\(\{\r\}\)</span> is the minimal functionally complete set.</p>
<p>Prov. noticed that <span class="math display">\[
p\r(q\r p) = \negp\lor(\negq\lor p) = \neg q
\]</span> This shows <span class="math inline">\(\neg\)</span> can be generated from <span class="math inline">\(\r\)</span>.</p>
<p>What’s more, <span class="math display">\[
p\lor q = \neg(\negp)\lor q=\negp\r q
\]</span> This shows <span class="math inline">\(\lor\)</span> can be generated from <span class="math inline">\(\neg\)</span> and <span class="math inline">\(\r\)</span>. As we proved before, <span class="math inline">\(\neg\)</span> can be expressed by <span class="math inline">\(\r\)</span>. So <span class="math inline">\(\lor\)</span> can be expressed by pure <span class="math inline">\(\r\)</span>.</p>
<p>Noticed that <span class="math inline">\(\{\neg, \lor\}\)</span> is the functionally complete, so <span class="math inline">\({\r}\)</span> is also functionally complete, and it must be minimal because only one element in this set.</p>
</blockquote>
<h5 id="normal-form-of-proposition-formula"># Normal Form of Proposition Formula</h5>
<p>Normal form is a formula form with special character, the most important normal form in proposition formula are <strong>Disjunctive Normal Form (DNF)</strong> and <strong>Conjunction Normal Form (CNF)</strong>. Because of the similarity, we only emphasize DNF in this part.</p>
<p>Disjunctive normal form are defined as the <strong>disjunction of the conjunction of literals</strong>.</p>
<blockquote>
<p>Ex. <span class="math display">\[
A(p,q,r) = (p\land q)\lor(p\land\negq)\lor(\neg p\land q\land r)
\]</span> is a DNF expression, the subformula <span class="math inline">\(p\land q, \ p\land \negq, \ \negp\land q\land r\)</span> are all conjunctions, and <span class="math inline">\(A\)</span> is the disjunction of them.</p>
</blockquote>
<p>If all the variable occurs exactly once in each conjuction in DNF, it’s called <strong>Principal DNF (PDNF)</strong>. The DNF above is not PDNF, but it’s possible to convert it into the PDNF. Actually, any satiable formula can be converted to PDNF by <strong>truth table</strong> or <strong>propositional equivlance calculus</strong>. The detalied technique will be describe in <a href="PDNF%20Transformation">PDNF Transformation</a>.</p>
<p>PDNF form play a significant role in the automatic prove like <a href="SAT%20Algorithm">SAT Algorithm</a>.</p>
<h5 id="inference-theory-in-proposition-logic-framework"># Inference Theory in Proposition Logic Framework</h5>
<p>Def. Let <span class="math inline">\(A_i, C\)</span> be the proposition formula, if <span class="math inline">\(\bigwedge A_i\r C\)</span> is tautology, we’ll say that <span class="math inline">\(A_i\)</span> <strong>infers</strong> <span class="math inline">\(C\)</span>, notes as</p>
<p><span class="math display">\[
\bigwedge A_i \Rightarrow C
\]</span></p>
<p>OR</p>
<p><span class="math display">\[
\cfrac{A_1,\ A_2,\ ... ,\ A_n}{C}
\]</span></p>
<p>The tautology <span class="math inline">\(\bigwedge A_i\r C\)</span> is called the <strong>formal structure</strong> of the inference process.</p>
<p>Based on the definition, to check if an inference is valid, we just need to check whether the formal structure is tautology, but in the most cases it’s not possible, because the <strong>predicate</strong> will replace the over-simplification concept design - proposition, there’s no method to check if a predicate is tautology.</p>
<p>A group of pre-proved inference rules are given here to help the prove of inference: <span class="math display">\[
\begin{align}
&amp;\text{Replacement Rule:}
&amp;&amp;A = B &amp;&amp;\Rightarrow \quad A\r B
\\~\\
&amp;\text{Modus Ponens:}
&amp;&amp;p,\ p\r q &amp;&amp;\Rightarrow \quad q
\\
&amp;\text{Modus tollens:}
&amp;&amp;p\r q,\ \negq  &amp;&amp;\Rightarrow \quad \negp
\\~\\
&amp;\text{Conjunction Introduction:}
&amp;&amp;p,\ q  &amp;&amp;\Rightarrow \quad p\land q
\\
&amp;\text{Conjunction Elimination:}
&amp;&amp;p\land q &amp;&amp;\Rightarrow \quad p
\\
&amp;\text{Disjunction Introduction:}
&amp;&amp;p &amp;&amp;\Rightarrow \quad p\lor q
\\~\\
&amp;\text{hypothetical syllogism:}
&amp;&amp;p\r q，q\r r  &amp;&amp;\Rightarrow \quad r
\\
&amp;\text{Disjunctive syllogism:}
&amp;&amp;p\lor q, \negq &amp;&amp;\Rightarrow \quad p
\\~\\
&amp;\text{Constructive Diellma:}
&amp;&amp;p\lor s,\ p\r q,\ s\r t &amp;&amp;\Rightarrow \quad q\lor t
\\
&amp;\text{Distructive Diellma:}
&amp;&amp;\negq\lor\neg t,\ p\r q,\ s\r t &amp;&amp;\Rightarrow \quad \negp\lor\neg s
\\
\end{align}
\]</span></p>
<h3 id="first-order-predicate-logic">2. First-order Predicate Logic</h3>
<p>The proposition logic model the proof process by atomic proposition, which is a</p>
<h5 id="quantifier"># Quantifier</h5>
<p>Concept “For any <span class="math inline">\(x\)</span>” is called <strong>Universal Quantifier</strong> or <strong>Generality Quantifier</strong>, notes as <span class="math inline">\(\any x\)</span>.</p>
<p>Concept “Exist <span class="math inline">\(x\)</span>” is called <strong>Existential Quantifier</strong>, notes as <span class="math inline">\(\exists x\)</span>.</p>
<p><strong>Term</strong> is defined recursively:</p>
<ol type="1">
<li>Single individual constant/variable is term.</li>
<li>If <span class="math inline">\(f(t_1, t_2, ..., t_n)\)</span> is function, where <span class="math inline">\(t_i\)</span> are all terms, then <span class="math inline">\(f(t_1, t_2, ..., t_n)\)</span> is also term.</li>
</ol>
<p>Afterwards <strong>Predicate Formula</strong> is defined as the connection of Term through three ways:</p>
<ol type="1">
<li><span class="math inline">\(P(t_1, t_2, ..., t_n)\)</span> is predicate formula where <span class="math inline">\(P\)</span> is a predicate symbol and <span class="math inline">\(t_i\)</span> are terms.</li>
<li>If <span class="math inline">\(P,Q\)</span> are both predicates, <span class="math inline">\(\neg P, P\land Q, P\lor Q, P\r Q, P\rl Q\)</span> are all predicates.</li>
<li>If <span class="math inline">\(P,Q\)</span> are both predicates, <span class="math inline">\(\any xP\)</span> and <span class="math inline">\(\exists P\)</span> are both predicates.</li>
</ol>
<p><span class="math inline">\(\exists x: ax^2+bx+c\)</span></p>
<p><span class="math display">\[
\begin{align}
\text{Quantifer Negation:} \qquad\\
&amp;\neg\any x:B(x) = \exists x: \neg B(x) \\
&amp;\neg\exists x:B(x) = \any x: \neg B(x) \\
\text{Quantifer Exchange:} \qquad\\
&amp;\any x \any y:A(x,y) = \any y\any x:A(x,y) \\
&amp;\exists x \exists y:A(x,y) = \exists y\exists x:A(x,y) \\
\text{Quantifer Elimination:} \qquad\\
&amp;\any xB = B \\
&amp;\exists xB = B \\
\text{Name Replacement:} \qquad\\
&amp;\any x \any y:A(x,y) = \any y\any x:A(x,y) \\
&amp;\exists x \exists y:A(x,y) = \exists y\exists x:A(x,y) \\
\end{align}
\]</span></p>
<p>Like the</p>
<p>Universal/Existential Substitution/Generalization Rule:</p>
<ol type="1">
<li><p>Universal Substitution Rule:</p>
<p>For any individual constant <span class="math inline">\(e\)</span>, <span class="math inline">\(\any x:A(x)\Rightarrow A(e)\)</span>.</p>
<p>For any individual <strong>variable</strong> <span class="math inline">\(y\)</span>, if <span class="math inline">\(y\)</span> does not occurs in the scope of <span class="math inline">\(x\)</span>, <span class="math inline">\(\any x: A(y)\Rightarrow A(y)\)</span>.</p></li>
<li><p>Universal Generalization Rule: <span class="math display">\[
B\r A(x) \Rightarrow B\r \any x:A(x)
\]</span></p></li>
<li><p>Existential Substitution Rule: <span class="math display">\[
\exists x:A(x)\Rightarrow A(e)
\]</span> where <span class="math inline">\(e\)</span> is a new individual constant notation which different from any in original expression.</p></li>
<li><p>Existential Generalization Rule:</p>
<p>For any individual constant <span class="math inline">\(e\)</span>, <span class="math inline">\(A(e)\Rightarrow \exists x:A(x)\)</span>.</p>
<p>For any individual variable <span class="math inline">\(y\)</span>, <span class="math inline">\(A(y)\Rightarrow \exists x:A(x)\)</span>.</p></li>
</ol>


</body>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</html>